---
import { getCollection } from "astro:content";
import { marked } from "marked";
import DOMPurify from "isomorphic-dompurify";
import dayjs, { type Dayjs } from "dayjs";
import { formatTime, calculateAbsoluteDate } from "../utils/dateUtils";
import { Badge } from "@astrojs/starlight/components";
import { transformContentData } from "../utils/contentUtils";

interface Reading {
  link: string;
  name: string;
  grad_only?: boolean;
  optional?: boolean;
}

interface BaseEvent {
  type: string;
  title: string;
  date: Dayjs;
  notes?: string;
  tentative?: boolean;
}

interface ExamEvent extends BaseEvent {
  type: "exam";
  content: string;
}

interface HomeworkEvent extends BaseEvent {
  type: "homework release" | "homework due";
  slug: string;
}

interface LectureEvent extends BaseEvent {
  type: "lecture";
  slug: string;
  readings?: Reading[];
}

const examsCollection = await getCollection("exams");
const exams = examsCollection
  .filter((entry) => entry.data.relative_date)
  .map((entry) => {
    const data = transformContentData(entry.data);
    return {
      type: "exam" as const,
      title: data.title,
      date: calculateAbsoluteDate(entry.data.relative_date!),
      content: data.content,
      notes: data.notes,
      tentative: data.tentative,
    } satisfies ExamEvent;
  });

const homeworks = (
  await getCollection("docs", (entry) => entry.id.startsWith("homework"))
).flatMap((entry) => {
  const data = transformContentData(entry.data);
  const events = [];
  if (data.relative_release) {
    events.push({
      slug: entry.id,
      type: "homework release" as const,
      title: data.title,
      date: calculateAbsoluteDate(data.relative_release),
      notes: data.notes,
      tentative: data.tentative,
    } satisfies HomeworkEvent);
  }
  if (data.relative_due) {
    events.push({
      slug: entry.id,
      type: "homework due" as const,
      title: data.title,
      date: calculateAbsoluteDate(data.relative_due),
      notes: data.notes,
      tentative: data.tentative,
    } satisfies HomeworkEvent);
  }
  return events;
});

const lecturesCollection = await getCollection("docs", (entry) =>
  entry.id.startsWith("lecture"),
);
const lectures = lecturesCollection
  .filter((entry) => entry.data.relative_date)
  .map((entry) => {
    const data = transformContentData(entry.data);
    return {
      slug: entry.id,
      type: "lecture" as const,
      title: data.title,
      date: calculateAbsoluteDate(entry.data.relative_date!),
      readings: data.readings,
      notes: data.notes,
      tentative: data.tentative,
    } satisfies LectureEvent;
  });

const events = [...exams, ...homeworks, ...lectures].sort(
  (a, b) => a.date.valueOf() - b.date.valueOf(),
);

// events is already sorted, so just check if the last event is in the past
// class concludes on the Friday of finals week

const concluded = calculateAbsoluteDate({
  week: 16,
  day: "Friday",
  time: "17:00:00",
}).isBefore(dayjs());
---

{
  !concluded && (
    <div class="controls-container">
      <span class="action primary" id="jumpToDateButton">
        Jump to Nearest Date
      </span>
      
      <!-- Filter Buttons -->
      <span class="action primary filter-button" id="filterAll" data-filter="all">All</span>
      <span class="action secondary filter-button" id="filterLecture" data-filter="lecture">Lectures</span>
      <span class="action secondary filter-button" id="filterHomework" data-filter="homework">Homeworks</span>
      <span class="action secondary filter-button" id="filterExam" data-filter="exam">Exams</span>
    </div>
  )
}

<div class="not-content ml-4 flex items-center lg:ml-0 lg:justify-center">
  <table class="border-separate border-spacing-y-2 text-sm">
    <thead>
      <tr>
        <th class="hidden lg:table-cell lg:min-w-[8rem]">Type</th>
        <th class="hidden lg:table-cell">Date</th>
        <th class="hidden lg:table-cell">Topic</th>
        <th class="hidden lg:table-cell">Content</th>
        <th class="hidden lg:table-cell">Notes</th>
      </tr>
    </thead>
    <tbody>
      {
        events.map((event) => (
          <tr
            class:list={[
              {
                "!bg-[var(--sl-color-accent-low)]": event?.tentative,
              },
              "tr-class",
            ]}
            data-date={event.date.toISOString()}
            data-type={
              event.type === "lecture"
                ? "lecture"
                : event.type === "exam"
                  ? "exam"
                  : "homework"
            }
          >
            <td class="td-class">
              {event?.tentative && <Badge text="Tentative" variant="tip" />}
              <div>{event.type}</div>
            </td>
            <td class="td-class">{formatTime(event.date)}</td>
            <td class="td-class">
              {(event.type === "homework release" ||
                event.type === "homework due") && (
                <a href={`/${event.slug}/`}>{event.title}</a>
              )}
              {event.type === "exam" && event.title}
              {event.type === "lecture" && event.title}
            </td>
            <td class="td-class">
              {event.type === "exam" && event.content}
              {event.type === "lecture" && event.readings && (
                <ul>
                  {event.readings.map((reading: Reading) => (
                    <li>
                      <a href={reading.link} target="_blank">
                        {reading.name}
                      </a>
                      {reading.grad_only && <span title="grad only">üßë‚Äçüéì</span>}
                      {reading.optional && <span title="not on quiz">üìµ</span>}
                    </li>
                  ))}
                </ul>
              )}
            </td>
            <td class="td-class">
              {event.notes && (
                <Fragment
                  set:html={marked(event.notes, { async: true })
                    .then((r) => DOMPurify.sanitize(r))
                    .catch((e) => `Markdown parse failure: ${e}.`)}
                />
              )}
            </td>
          </tr>
        ))
      }
    </tbody>
  </table>

  <style>
    @reference "tailwindcss";

    .td-class {
      @apply border-0 px-4 py-3  lg:first:rounded-t-none lg:first:rounded-bl-lg lg:first:rounded-tl-lg lg:last:rounded-b-none lg:last:rounded-br-lg lg:last:rounded-tr-lg;
    }

    .tr-class {
      @apply mb-4 flex flex-col rounded-lg odd:bg-[var(--sl-color-gray-6)] even:bg-[var(--sl-color-gray-7)] lg:table-row;
    }
    
    /* Dynamic zebra striping classes for filtered content - higher specificity */
    tr[data-date].odd-stripe {
      background-color: var(--sl-color-gray-6);
    }
    
    tr[data-date].even-stripe {
      background-color: var(--sl-color-gray-7);
    }

    /* Controls container for same-row layout */
    .controls-container {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin-top: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    /* Mobile-specific styling */
    @media (max-width: 768px) {
      .controls-container {
        gap: 0.75rem;
        justify-content: center; /* Center buttons on mobile */
      }
      
      .action {
        padding: 0.75rem 1.5rem;
        font-size: var(--sl-text-base);
        min-width: 80px; /* Ensure minimum width for circular appearance */
        text-align: center;
      }
    }

    /* Filter container styling */
    .filter-container {
      margin-top: 1.5rem;
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .action {
      display: inline-block;
      cursor: pointer;
      margin-top: 1rem;
      margin-bottom: 1rem;
      gap: 0.5em;
      align-items: center;
      border-radius: 999rem;
      padding: 0.5rem 1.125rem;
      color: var(--sl-color-white);
      line-height: 1.1875;
      text-decoration: none;
      font-size: var(--sl-text-sm);
      border: 1px solid var(--sl-color-text-accent);
    }
    .action.primary {
      background: var(--sl-color-text-accent);
      color: var(--sl-color-black);
    }
    ul {
      padding-left: 0.5rem;
    }
    @keyframes fadeHighlight {
      from {
        background-color: var(--sl-color-accent);
      }
    }

    .highlight {
      animation: fadeHighlight 2s ease-out forwards;
    }
    /* Ensure hidden attribute wins over flex/table display from classes */
    tr[hidden] {
      display: none !important;
    }
  </style>

  <script>
    import dayjs from "dayjs";

    // function to jump to the nearest date, button and functionality is set here
    const jumpToDate = () => {
      const today = dayjs();
      const rows = document.querySelectorAll("tr[data-date]:not([hidden])");
      const nearestRow = Array.from(rows)
        .filter(
          (row) => {
            const rowDate = dayjs(row.getAttribute("data-date"));
            return rowDate.isSame(today, 'day') || rowDate.isAfter(today, 'day')
          },
        ) // Filter out past events
        .sort((a, b) => {
          return (
            Math.abs(today.diff(dayjs(a.getAttribute("data-date")) ?? today)) -
            Math.abs(today.diff(dayjs(b.getAttribute("data-date")) ?? today)) // Sort by diff between today's date and event's date
          );
        })[0] as HTMLElement; // Return first item (nearest date)
      if (!nearestRow) return;
      const originalColor = window.getComputedStyle(nearestRow).backgroundColor;
      nearestRow.style.backgroundColor = originalColor; // Set original color inline
      nearestRow.classList.add("highlight");

      setTimeout(() => {
        nearestRow.classList.remove("highlight");
        nearestRow.style.backgroundColor = ""; // Revert to stylesheet color
      }, 2000);

      // Check for prefers-reduced-motion setting
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      nearestRow.scrollIntoView({ 
        behavior: prefersReducedMotion ? "auto" : "smooth", 
        block: "start" 
      });
    };

    const updateZebraStriping = () => {
      const visibleRows = document.querySelectorAll("tr[data-date]:not([hidden])");
      visibleRows.forEach((row, index) => {
        const htmlRow = row as HTMLElement;
        // Remove existing odd/even classes
        htmlRow.classList.remove('odd-stripe', 'even-stripe');
        // Add appropriate class based on visible index
        if (index % 2 === 0) {
          htmlRow.classList.add('even-stripe');
        } else {
          htmlRow.classList.add('odd-stripe');
        }
      });
    };

    // Map URL hash to filter type
    const hashToFilter: Record<string, string> = {
      '#all': 'all',
      '#lectures': 'lecture',
      '#homeworks': 'homework',
      '#exams': 'exam'
    };

    // Map filter type to URL hash
    const filterToHash: Record<string, string> = {
      'all': '#all',
      'lecture': '#lectures',
      'homework': '#homeworks',
      'exam': '#exams'
    };

    // Handles button colors, when a user selects a button that becomes the "active" filter indicated by color
    const updateLinkButtonVariants = (activeFilter: string) => {
      const buttons = document.querySelectorAll('.filter-button');
      buttons.forEach((button) => {
        const filterType = button.getAttribute('data-filter');
        const isActive = filterType === activeFilter;
        
        // Update the class for styling
        if (isActive) {
          button.classList.remove('secondary');
          button.classList.add('primary');
        } else {
          button.classList.remove('primary');
          button.classList.add('secondary');
        }
      });
    };

    const applyFilter = (filterType = 'all') => {
      const rows = document.querySelectorAll("tr[data-date]");
      rows.forEach((row) => {
        const type = row.getAttribute("data-type");
        const show = filterType === "all" || type === filterType;
        (row as HTMLElement).hidden = !show;
      });
      
      // Update zebra striping after filtering
      updateZebraStriping();
      
      // Update button variants
      updateLinkButtonVariants(filterType);
      
      // Update URL without triggering page reload
      const newHash = filterToHash[filterType] || '#all';
      if (window.location.hash !== newHash) {
        history.replaceState(null, '', newHash);
      }
    };

    // Grab the filter from the url if there is one
    const getFilterFromUrl = () => {
      const hash = window.location.hash || '#all';
      return hashToFilter[hash] || 'all';
    };

    // Initialize filter based on URL hash
    document.addEventListener("DOMContentLoaded", () => {
      const initialFilter = getFilterFromUrl();
      applyFilter(initialFilter);
    });

    // Listen for hash changes (browser back/forward, manual URL changes)
    window.addEventListener('hashchange', () => {
      const newFilter = getFilterFromUrl();
      applyFilter(newFilter);
    });

    // Add click handlers for filter buttons
    document.querySelector("#filterAll")?.addEventListener("click", (e) => {
      e.preventDefault();
      applyFilter('all');
    });

    document.querySelector("#filterLecture")?.addEventListener("click", (e) => {
      e.preventDefault();
      applyFilter('lecture');
    });

    document.querySelector("#filterHomework")?.addEventListener("click", (e) => {
      e.preventDefault();
      applyFilter('homework');
    });

    document.querySelector("#filterExam")?.addEventListener("click", (e) => {
      e.preventDefault();
      applyFilter('exam');
    });

    document
      .querySelector("#jumpToDateButton")
      ?.addEventListener("click", () => {
        jumpToDate();
      });
  </script>
</div>
